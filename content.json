{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"binary-index-tree","slug":"binary-index-tree","date":"2017-06-14T15:08:36.000Z","updated":"2017-06-14T15:18:12.116Z","comments":true,"path":"2017/06/14/binary-index-tree/","link":"","permalink":"http://yoursite.com/2017/06/14/binary-index-tree/","excerpt":"","text":"Binary Index Tree (BiTree) is a simple data strutrure for fast calculation of the first n eleemnt’s sum. It is a logical tree stored in an array physically. Ordered tree. Definition: A BiTree is an intermediate array C for an input array V. C has the same length with V. C could be of 0 size when V is of size 0. For an non-empty C, every element has an parent except the 0th eleement, namely root element. BiTree satisfies two condtiosn; 1) The parent of i-th (i &gt; 0 &amp; i &lt; C.length) element is parent(i) = i - (i &amp; (-i)). 2) C[0] = V[0] and C[i] records the sum from parent(i) + 1 to i of V elements. Node i’s parent;s location is unset the lowest significant bit of i. In this way, the tree structure of BiTree (length 16) is as follows: 123456789graph TD subgraph SVN Architecture client1--&gt;|read / write|SVN((SVN server)) client2--&gt;|read only|SVN client3--&gt;|read / write|SVN client4--&gt;|read only|SVN client5(...)--&gt;SVN SVN---|store the data|sharedrive end Nodes record the subordinate (zero-based). Visually generally, subordinate j &gt; i if i is the ancest of j, or i belongs to the left sibling subtree of j or j’s ancest. Further more C[i] (i &gt; 0) records the sum of all left subling subtree plus A[i]. Then comes some questions related to tree structure: What is the next sibling of i node? Try to get a smallest number greater j than i that if j and i are equal after removing the lowest significant bit. What is the previous sibling of i node? It is the same to upper question. The similar question is what are the all the children of nodes i, the first child ort the last hcild. Note that a node may not have a child, a left sibling or a right sibling base on where hte node is. And also how to manipulate the data structure: How to get C[i]? Accumulating V from P[parent(i) + 1] to i is not a good idea. One can calculate the subtree’s sum by accumulating C[i-1] and C values of all its ancestor till parent(i) (exclusive); What if V[i] change? For the Node i change, its children node and parent node and the left subling are not affected except the right sublings. Can a BiTree insert a node? what if adding one in the last? Can a BiTree remove a node? what is removing the last node? Code are as follows: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250/** * input array */public final int[] v;/** * intermediate sum */public final int[] c;private BinaryIndexTree(int[] arr, int[] carr) &#123; v = arr; c = carr;&#125;public static BinaryIndexTree getInstance(int[] arr) &#123; Objects.requireNonNull(arr); BinaryIndexTree tree = new BinaryIndexTree(arr, new int[arr.length]); tree.initialize(); return tree;&#125;/** * @param i end index * @return sum of array v from 0th element to i-th */public int sum(int i) &#123; assert (i &gt;= 0 &amp;&amp; i &lt; v.length); int result = c[i]; while (hasParent(i)) &#123; i = parent(i); result += c[i]; &#125; return result;&#125;/** * @param i start index * @param j end index * @return sum of array v from i-th element to j-th */public int sum(int i, int j) &#123; assert (i &gt;= 0 &amp;&amp; i &lt;= j &amp;&amp; j &lt; v.length); return sum(j) - (i == 0 ? 0 : sum(i - 1));&#125;/** * @param i index to be set * @param value value to be updated as */public void update(int i, int value) &#123; assert (i &gt;= 0 &amp;&amp; i &lt; v.length); updateDiff(i, value - v[i]);&#125;/** * @param i index to be update * @param plus difference to be added */public void updateDiff(int i, int plus) &#123; assert (i &gt;= 0 &amp;&amp; i &lt; v.length); v[i] += plus; c[i] += plus; while (hasNextSibling(i)) &#123; i = nextSibling(i); c[i] += plus; &#125;&#125;/** * @param i index of node * @return index of parent node, check &#123;@link #hasParent(int)&#125; first */public int parent(int i) &#123; // Note parent(0) = 0 return i - (i &amp; (-i));&#125;/** * @param i index of node * @return true if node i has parent */public boolean hasParent(int i) &#123; return i &gt; 0 &amp;&amp; i &lt; v.length;&#125;/** * @param i index of node * @return index of next sibling of node i, check * &#123;@link #hasNextSibling(int)&#125; first */public int nextSibling(int i) &#123; return i + (i &amp; (-i));&#125;/** * @param i index of node * @return true if node i has next sibling (right sibling) */public boolean hasNextSibling(int i) &#123; int next = nextSibling(i); return hasParent(next) &amp;&amp; hasParent(i) &amp;&amp; parent(next) == parent(i);&#125;/** * @param i index of node * @return index of previous sibling of node i, check * &#123;@link #hasPreviousSibling(int)&#125; first */public int previousSibling(int i) &#123; return i - ((i &amp; (-i) &gt;&gt;&gt; 1));&#125;/** * @param i index of node * @return true if node i has previous sibling (left sibling) */public boolean hasPreviousSibling(int i) &#123; int previous = previousSibling(i); return hasParent(previous) &amp;&amp; hasParent(i) &amp;&amp; parent(previous) == parent(i);&#125;/** * @param i index of node * @return index of the first child, check &#123;@link #hasChild(int)&#125; first */public int firstChild(int i) &#123; return i + 1;&#125;/** * @param i index of node * @return the index of the last child, check &#123;@link #hasChild(int)&#125; first */public int lastChild(int i) &#123; return i == 0 ? (highestBit(v.length)) : i + ((i &amp; (-i) &gt;&gt;&gt; 1));&#125;// MSB is betterprivate int highestBit(int i) &#123; assert (i &gt; 0); while (i != (i &amp; (-i))) &#123; i -= i &amp; (-i); &#125; return i;&#125;/** * @param i index of node * @return true if node i has child node */public boolean hasChild(int i) &#123; return i &gt;= 0 &amp;&amp; i &lt; v.length &amp;&amp; (i &amp; 1) == 0 &amp;&amp; i + 1 &lt; v.length;&#125;/** * @param i index of node * @return indices of all children of node i */public int[] childs(int i) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); int j = i + 1; while (j &lt; v.length &amp;&amp; parent(j) == i) &#123; list.add(j); j = j + j &amp; (-j); &#125; return list.stream().mapToInt(Integer::intValue).toArray();&#125;/** * @param i index of node * @return indices of all next siblings of node i */public int[] nextSiblings(int i) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); // In case of dead loop if (i != 0) &#123; int p = parent(i); int j = nextSibling(i); while (j &gt;= 0 &amp;&amp; j &lt; v.length &amp;&amp; parent(j) == p) &#123; list.add(j); j = nextSibling(j); &#125; &#125; return list.stream().mapToInt(Integer::intValue).toArray();&#125;/** * @param i index of node * @return indices of all previous siblings of node i */public int[] previousSiblings(int i) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); // In case of dead loop if (i != 0) &#123; int p = parent(i); int j = previousSibling(i); while (j &gt;= 0 &amp;&amp; j &lt; v.length &amp;&amp; parent(j) == p) &#123; list.add(j); j = previousSibling(j); &#125; &#125; return list.stream().mapToInt(Integer::intValue).toArray();&#125;/** * Add a value to a BiTree to build a new BiTree * @param value to add at end * @return a new BiTree, this does not change */public BinaryIndexTree add(int value) &#123; int[] newV = new int[v.length + 1]; int[] newC = new int[v.length + 1]; System.arraycopy(v, 0, newV, 0, v.length); System.arraycopy(c, 0, newC, 0, c.length); newV[v.length] = value; BinaryIndexTree tree = new BinaryIndexTree(newV, newV); tree.calC(v.length); return tree;&#125;/** * Remove the last value * @return a new BiTree, this does not change */public BinaryIndexTree remove() &#123; assert (v.length &gt; 0); return new BinaryIndexTree(Arrays.copyOf(v, v.length - 1), Arrays.copyOf(c, c.length - 1));&#125;private void initialize() &#123; for (int i = 0; i &lt; c.length; i++) &#123; calC(i); &#125;&#125;private void calC(int i) &#123; int sum = v[i]; if (hasParent(i)) &#123; int p = parent(i); int k = i - 1; while (k &gt; p) &#123; sum += c[k]; k = parent(k); &#125; &#125; c[i] = sum;&#125; Complexity Analysis: Space O(n) Time: update(log(n)) sum(log(n)) Open question: An array can be viewed as a tree only a parent function p(i) map a child to its parent. Right? and BiTree just define the p(i) and then one can use the underlying magic math to get good property. Is there is two-dimensional BiTree? How does it look like?V[m][n] and C[m][n] C[i][j] = sum(V[k][h]) p[i] &lt; k &lt;= i &amp; p(j) &lt; h &lt;= j;sum[i][j] = sum(C[h][k]) p[i] &lt; k &lt;= i &amp; p(j) &lt; h &lt;= j;How to update V[i][j]? update all C[h][k] h is i’s sibling &amp; k is j’s right sibling.","categories":[],"tags":[{"name":"data structure, tree","slug":"data-structure-tree","permalink":"http://yoursite.com/tags/data-structure-tree/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-06-05T01:00:26.024Z","updated":"2017-06-05T01:00:26.024Z","comments":true,"path":"2017/06/05/hello-world/","link":"","permalink":"http://yoursite.com/2017/06/05/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}